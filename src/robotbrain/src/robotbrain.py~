#!/usr/bin/env python
import rospy
import motionplanner
import pathplanner
import location
import pose
#from gc_msgs import MotionMsg  # for sending commands to motors
#from gc_msgs import BumpMsg    # for listening to bump sensors
#from gc_msgs import PoseMsg    # for listening to when the kinect sees a block
import time
#
# This node is the state machine that controls robot behavior
#

#####################
## state methods ####
#####################

# params: none
# returns: void
# starts all publishers, subscribers; loads map and fills associated variables 
def init():
    #TODO
    #motionPub = rospy.Publisher("command/Motors", MotionMsg);
    #bumpSub = rospy.Subscriber('bumpData', BumpMsg, handleBumpMsg);
    #blockSeenSub = rospy.Subscriber('blockSeen', PoseMsg, handleBlockSeenMsg);

    # loading and processing map
    # TODO
    pass

# params: none
# returns: none
# Robot needs more blocks, but does not know where to find them.
# Travel to unexplored parts of the map to look for new blocks
def wander():
    # TODO

    pass

# params: none
# returns: none
# Robot needs to move from it's current location to a destination
# global waypoints contains a list of points the robot can travel to in straight-line paths
def travel():
    # TODO
     
    # if have reached the current waypoint, stop and move to the next waypoint. If at end of wayponts, enter seatch
    if (getDistance(currentPose, waypointList[0]) < POSITION_THRESHOLD):
        motionPlanner.stopWheels();
        previousWaypointPose = currentPose;

        # if there are more waypoints, travel to next one
        if len(waypointList > 1):
            waypointList = waypointList[1:];

        # if there are no more waypoints, are at expected block location. start searching.     
        else:
            robotState = 'searching';

    # if haven't reached the current waypoint, travel towards it
    else:
        # tAre you referring to the odometry package and theakes currentPose, destinationLoc, angVel, vel, startPose
        motionPlanner.travelTowards(currentPose, waypointList[0], .01, .15, previousWaypointPose); 
    return

# params: none
# returns: none
# Robot has reached a place where it believes a block is
# turn in slow circle looking for block. If time-out, reject block location and set course for a new one
# search gets called repeatedly, so can switch states in the middle
def search():
    motionPlanner.rotate(.1);  #TODO: check that this is a good speed
    
    # if haven't been searching too long, keep searching
    if(searchCount < MAX_SEARCH_COUNT):
        time.sleep(.5);            # should be moving slow enough that nothing passes in and out of view in this time
                                   # sleeping keeps count from getting crazy-high
        searchCount += 1;

    # if have been searching too long, give up on this block. Might not actually exist
    else: 

       # if know the locations of more blocks, set path to them and go get them                                      
       if (len(blockLocations) > 1):
           blockLocations = blockLocations[1:];
           #waypointsList = pathPlanner.plotPath(currentPose, blockLocations[0])
           robotState = 'travelling'

       # if don't know the location of more blocks, wander                                                           
       else:
           robotState = 'wandering'

    return

# params: none
# returns: none
# Robot has a block currently in its vision. 
# Move until block hits the bump sensors at the mouth of the conveyor belt
def consume():
    # TODO
    # waiting on will to figure out how this will work  - how close can the kinect be?
    pass

# params: none
# returns: none
# Robot has a block on the conveyor belt
# Move conveyor belts so block is added to wall
# this is an atomic action
def digest():
    # TODO: this is a simple implementation that doesn't reverse belts if something gets stuck

    # stop wheel motors and start ramp motors to move block up ramp
    motionPlanner.stopWheels();
    motionPlanner.startEatingBelts();
    motionPlanner.setHamperAngle(10); # so block can fall down sucessfully
                                      # TODO: get a real value for this

    # wait for block to go up the ramp
    while(inHamperFlag < 1): 
        time.sleep(1);   # wait for one second
  
    time.sleep(1);       # in case block needs to finish falling
    inHamperFlag = 0     # resetting flag

    # once block is in hamper, use hamper belts to push block into forming wall
    motionPlanner.stopEatingBelts();
    motionPlanner.setHamperAngle(0); # fully close hamper so conveyor belts can work
    motionPlanner.startHamperBelt();
    time.sleep(5)                    # wait for blocks to be pushed into right shape

    
    # turn off motors 
    motionPlanner.stopHamperBelt();

    # if know the locations of more blocks, set path to them and go get them
    if (len(blockLocations) > 1):
        blockLocations = blockLocations[1:];
        waypointsList = pathPlanner.plotPath(currentPose, blockLocations[0])
        robotState = 'travelling'
    # if don't know the location of more blocks, wander
    else:
        robotState = 'wandering'
    
    return

# params: none
# returns: void
# Robot has finished gathering blocks; commands robot to travel to endLocation and open hatch
def dispense():
    # TODO
    #wayPointList = pathPlanner.plotPath(currentPose, END_LOCATION);


    pass


##################
# Helper methods #
##################

# params: pose: a Pose
#         loc: a Location 
# returns: distance between them (absolute value)
def getDistance(pose, loc):
   return math.sqrt((pose.getX()-loc.getX())**2 + (pose.getY()-loc.getY())**2) 

###############################
# Interrupt-handling methods ##
###############################

# params: none
# returns: none
# based on which bump sensor went off, call appropriate respose
def handleBumpMsg(msg):
    # bump sensors 0 and 1 are at the mouth
    if (msg.bumpNumber <= 1):
        #if are currently searching and something hits these bump sensors, are eating the block
        if robotState == 'consuming': 
            searchCount = 0;
            robotState = 'digesting';
    # bump sensor 2 is at the end of the conveyor belt. Indicates that partially done digesting
    elif (msg.bumpNumber == 2):
        if (robotState == 'digesting'):
            inHamperFlag = 1; #used by digesting method

    else:
        #msg = MotionMsg(); # defaults to 0
        motionPlanner.stopWheels();
        # not sure where other bump sensors on chassis will be; 
        # should stop and back away if they are hit
        # TODO    
    return

# param: msg PoseMsg
# return: none
# takes in message from kinect indicating that a block has been seen
def handleBlockSeenMsg(msg):
   # TODO
   
   # waiting on Will to see how this will work
   pass

############
## Main ####
############


if __name__ == '__main__':
    # defining variables related to robot's state
    robotState = 'wandering'               # the state of the robot; can be wandering, traveling, searching, consuming
                                           #    digesting, dispensing 
    searchCount = 0                        # counter used to ensure that don't spend too long searching
    numBlocksCollected = 0                 # number of blocks that the robot has collected so far
    blockLocations = []                    # list of locations of blocks
    waypointList = []                      # list of waypoints to current destination
    inHamperFlag = 0                       # flag used to indicate whether a block on the conveyor belt
                                           #  has made it to the hamper
    currentPose = pose.Pose(0.0,0.0,0.0);
    previousWaypointPose = pose.Pose(0.0, 0.0, 0.0); #used for travel

    # objects
    motionPlanner =motionplanner.MotionPlanner();
    #pathPlanner = pathplanner.PathPlanner();
   
    # constants
    NUM_BLOCKS_NEEDED = 9                  # number of blocks needed to complete wall
    MAX_SEARCH_COUNT = 500                 # arbitrary value; should be tested and set
    POSITION_THRESHOLD = .005              # acceptable error to reaching a position. In meters.    
    END_LOCATION = location.Location(0.0, 0.0);

    try:
        init()                             # load map, initialize publishers, subscribers

        # while the robot needs more blocks to complete the wall, gather blocks
        while(numBlocksCollected < NUM_BLOCKS_NEEDED):
            if (robotState == 'wandering'):
                wander()

            elif (robotState == 'traveling'):
                travel()

            elif (robotState == 'searching'):
                search()

            elif (robotState == 'consuming'):
                consume()

            elif (robotState == 'digesting'):
                digest()

        # once the robot has enough blocks to complete the wall, leave the wall    
        dispense()
        rospy.spin()          # keeps python from exiting until node is stopped
    except rospy.ROSInterruptException: pass
