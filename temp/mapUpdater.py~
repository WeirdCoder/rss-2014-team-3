#!/usr/bin/env python                                                                                   
import rospy
import math
from gc_msgs import ObstacleMsg
#
# This node takes in messages from the sonar (and maybe kinect?) containing the locations of 'hits', It converts those points 
# into obstacles, and sends those obstacles out in ObstacleMsgs to the robot brain to update the map. 
#

############
# Handlers #
############

# params: msg: SonarMsg
# returns: none
# adds point from sonar message to point list
# on certain conditions, turn points in list into an obstacle and send out obstacle message
def handleSonarMsg(msg):
    # TODO
    pass


# params: Obstacle obstacle
# returns: none
# puts obstacle into message and sends
def sendObstacleMsg(obstacle):
    # from obstacle, create list of x,y points
    xList = []
    yLst = []
    pointList = obstacle.getLocationList()
    for point in pointList:
        xList.append(point.getX())
        yList.append(point.getY())

    # create and publish message
    msg = ObstacleMsg()
    msg.xPosList = xList
    msg.yPosList = yList
    obstaclePub.publish(msg)

    return


###################
# Helper messages #
###################

# params: point: Location of latest observed sonar hit
#         pointList: list of Locations of already observed sonar hits
# returns: boolean
# compared the new point to the previous points and assesses whether they are part of the same obstacle
def checkSameObstacle(point, pointList):
    # TODO

    # a new point belongs to the obstacle that is being formed in pointList if the following condition are met:
    # - the new point is not too far from the previous point (where 'too far' is defined by a constant)
    # - the new point is not too far from a line between the first point and the middle point (defined by a constant)
   

    # checking the first condition
    if (distancePointToPoint(point, pointList[-1]) < THRESHOLD_DIST_BETWEEN_POINTS):
        middleIndex = len(pointList)/2
       # if there aren't enough points to check the second condition, assume point should be included
        if (middleIndex < 1):
            return True

        # checking second condition
        elif:(distancePointToLine(point, pointList[0], pointList[middleIndex]) < LINE_DEVIATION_THRESHOLD):
            return True
                  
    return False 

# param Location point1
#       Location point2
# returns: float distance between points
# calculates distance between two points
def distancePointToPoint(pont1, point2):
    distance = math.sqrt((point1.getX() - point2.getX())**2 + (point1.getY()-point2.getY())**2)
    return distance


# params: Location point
#         Location endpoint1 an endpoint of the line
#         Location endpoint2 other endpoint of the line
# returns: distance of point to line
# calculates distance of point to line
def distancePointToLine(point, endpoint1, endpoint2):
    # TODO
    # finding equation of line in a*x + b*y + c = 0 form
    # starting with y = mx + intercept
    m = (endpoint1.getY()-endpoint2.getY())/(endpoint1.getX()-endpoint2.getX());
    intercept = endpoint1.getY()-m*endpoint2.getX()
    a = -m
    b = 1 
    c = -intercept

    # use formula distance = (a*x_o + b*y_0 + c) / sqrt(a**2 + b**2)
    distance = (a*point.getX() + b*point.getY() + c) / math.sqrt(a**2 + b**2)
    return distance

# parans: point: Location of latest observed sonar hit
#         mapList: list of objects in map
# returns: boolean
# checks to see if the point is part of any of the currently known obstacles
def checkIfNewObstacle(point, mapList):
    # TODO
    return

# param: pointList: list of Locations that should be fit to a line
# returns: [Location endpoint1, Location endpoint2, error]
# fits a line to given list of points. Returns line parameters and greatest distance of point to line
def fitLine(pointList):
    # TODO
    pass

# param: Location axisEndpoint1: one endpoint of axis of symmetry
#        Location axisEndpoint2: other endpoint of axis of symmetry
#        float width: width of rectangle
# returns: Obstacle object containing points of rectangle
# creates rectangle given line of symmetry and width
def createRectangle(axisEndpoint1, axisEndpoint2, width):
    
    # the corners will lie along a perpindicular line that passes through each end point
    # each corner will lie a distance of width/2 along this perpendicular line
    perpindicularSlope = -(axisEndpoint1.getX()-axixEndpoint2.getX())/(axisEndpoint1.getY()-axixEndpoint2.getY()) 
    perpAngle = math.atan(perpindicularSlope)

    # creating the points of the rectangle
    corner1 = Location(axisEndpoint1.getX() + .5*width*math.cos(perpAngle), axisEndpoint1.getY() + .5*width*math.sin(perpAngle))
    corner2 = Location(axisEndpoint1.getX() - .5*width*math.cos(perpAngle), axisEndpoint1.getY() -.5*width*math.sin(perpAngle))
    corner3 = Location(axisEndpoint2.getX() - .5*width*math.cos(perpAngle), axisEndpoint2.getY() -.5*width*math.sin(perpAngle))
    corner4 = Location(axisEndpoint2.getX() + .5*width*math.cos(perpAngle), axisEndpoint2.getY() +.5*width*math.sin(perpAngle))

    newObstacle = Obstacle([corner1, corner2, corner3, corner4])
    return newObstacle

#######
#Main #
#######
if __name__ == if __name__ == '__main__':

    # creating subscribers and publishers
    obstaclePub = rospy.Publisher("mapUpdates", ObstacleMsg);

    # keep track of state
    mapList = []
    

    # defining constants
    # TODO: get real values for these
    THRESHOLD_DIST_BETWEEN_POINTS = .05 # in meters; if two consecutive points are more than this distance apart
                                        # they will be considered part of sepearate obstacles

    LINE_DEVIATION_THRESHOLD = .03      # in meters; if a point is this far from a line, it will not be considered to be on that line
    SONAR_UNCERTAINTY = .01             # in meters; the error of the sonar reading
    try:
        
       # wait for messages
       rospy.spin()     # keeps python from exiting until node is stopped
    

    except rospy.ROSInterruptException: pass

        
